<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../css/schedule.css" />
    </head>
    <body>
        <main role="main">
            <h1>2025-winter</h1>
                <table style="width:100%;">
        <colgroup>
            <col style="width: 1%">
            <col style="width: 2%">
            <col style="width: 95%">
        </colgroup>
        <thead>
            <tr class="header">
                <th>Speaker</th>
                <th>Time ‚àß Location</th>
                <th>Paper</th>
            </tr>
            <tr class="odd">
                <th></th>
                <th colspan="2">Abstract</th>
            </tr>
        </thead>
        <tbody>

        <tr class="odd">
            <td>Matthew Keenan</td>
            <td>February 14th, 4-5pm in 4901 BBB</td>
            <td><a href="https://arxiv.org/pdf/2311.13995">Explicit Refinement Types</a></td>
        </tr>
        <tr class="even">
            <td></td>
            <td colspan="2">We present ùúÜert, a type theory supporting refinement types with explicit proofs. Instead of solving refinement constraints with an SMT solver like DML and Liquid Haskell, our system requires and permits programmers to embed proofs of properties within the program text, letting us support a rich logic of properties including quantifiers and induction. We show that the type system is sound by showing that every refined program erases to a simply-typed program, and by means of a denotational semantics, we show that every erased program has all of the properties demanded by its refined type. All of our proofs are formalised in Lean 4.<br></td>
        </tr>

        <tr class="odd">
            <td>Thomas J. Porter</td>
            <td>January 17th, 4-5pm in 2901 BBB</td>
            <td><a href="https://popl25.sigplan.org/details/wits-2025-papers/2/Incremental-Bidirectional-Typing-via-Order-Maintenance">Incremental Bidirectional Typing via Order Maintenance</a></td>
        </tr>
        <tr class="even">
            <td></td>
            <td colspan="2">In live programming systems, editor services such as type checking and evaluation are continually provided while the user is editing the program. The live paradigm offers benefits to developer experience and productivity. Generally editor services are stateless transformations that take only the current the program text as input, and compute the result from scratch. This presents a challenge to implementing live editors at scale, since the execution time will grow with the size of the program, and at some point will take too long to be recomputed between each edit.<br>This work presents a solution in the form of an incremental algorithm for maintaining a total static analysis of a program in a simple gradually typed language. Each edit action triggers an update to an enriched program data structure, yielding updated static information more efficiently than a fresh pass would. The algorithm is presented as a small-step dynamics to propagate updates through the enriched program data structure. Most updates flow according to the base bidirectional type system. Additional pointers are maintained to connect bound variables and their binding locations. Order maintenance data structures are employed to efficiently maintain these pointers and to prioritize the order of update propagation. We prove this algorithm equivalent to naive reanalysis in the Agda theorem prover. We implement the algorithm in the Incremental Hazelnut language workbench. We evaluate its performance on edit traces from real users as well as synthetic examples.<br></td>
        </tr>

        </tbody>
    </table>


        </main>
    </body>
</html>
